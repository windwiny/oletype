# coding: utf-8
import io
import json
import os.path
import sys


class Cfg():
    '''Config TODO  sync rb/py file'''
    OUT_EXCEL_INFO_FN = "excel.info.json"

    N_SUMM = "summary"
    N_META = 'meta'

    N_co = "collections"
    N_co_doc = "co_doc"

    N_e = "enumerations"
    N_e_unique = "uniqued"
    N_e_doc = "e_doc"
    N_e_table_head = "e_table_head"
    N_e_table_rows = "e_table_rows"
    N_e_remarks_doc = "e_remarks_doc"
    N_e_table_format_incorrect = "e_ERROR"

    N_c = "classes"
    N_c_doc = "c_doc"
    N_c_remarks_doc = "c_remarks_doc"
    N_c_example_doc = "c_examples_doc"

    N_m = "methods"
    N_m_doc = "m_doc"
    N_m_return = "m_return"
    N_m_return_doc = "m_return_doc"
    N_m_parameters_doc = "m_parameters_doc"
    N_m_parameters_as = "m_parameters_as"
    N_m_p_table = "m_p_table"
    N_m_p_table_head = "m_p_table_head"
    N_m_p_table_rows = "m_p_table_rows"
    N_m_remarks_doc = "m_remarks_doc"
    N_m_example_doc = "m_example_doc"

    N_p = "properties"
    N_p_doc = "p_doc"
    N_p_type = "p_type"
    N_p_syntax_doc = "p_syntax_doc"
    N_p_return_doc = "p_return_doc"
    N_p_property_value_doc = "p_property_value_doc"
    N_p_remarks_doc = "p_remarks_doc"
    N_p_example_doc = "p_example_doc"

    OUT_EXCEL_PY_FN = "oletype/excel.py"
    OUT_EXCEL_PYI_FN = OUT_EXCEL_PY_FN + "i"
    MYPKGNAME = "excel."
    MYPKGNAME = ""

    # python \Python311\Lib\site-packages\win32com\client\makepy.py
    #  Generating to C:\Users\user1\AppData\Local\Temp\gen_py\3.11\00020813-0000-0000-C000-000000000046x0x1x9.py
    # ole_class_pre: str = "<class 'win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    # ole_class_pre2: str = "win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    OLE_CLASS_PRE: str = "<class 'win32com."

    BUILTINS_CLASS = [clsn for clsn in dir(__builtins__) if type(getattr(__builtins__, clsn)) == type]
    BUILTINS_CLASS.append('None')
    OBJECT_PROPERTIES = [repr(i) for i in dir(object())]
    OLEOBJECT_SKIP_PROPERTY = ['CLSID', '__weakref__', '_oleobj_', 'coclass_clsid']
    OLEOBJECT_SKIP_EXCEPTION_PROPERTY = ['Visible']

    OUTFILE_HEADER = '''# coding: utf-8

# Generated by oletype, win32com(excel) object py/pyi file
#   for ide tips
#
# Usage:
#   from win32com.client import Dispatch
#   from oletype import excel
#   exapp = excel.Application = Dispatch('excel.application')  #declare app obj
#   exapp.   #  get ide auto type hit
'''
    IMPORTS = '''
from enum import IntFlag, unique
import datetime
'''
    num = 0


def check_or_exit():
    if not os.path.exists(Cfg.OUT_EXCEL_INFO_FN):
        print(f'not exists info.json file {Cfg.OUT_EXCEL_INFO_FN}')
        sys.exit(2)


def load_info_from_json(fn: str, kvs: dict):
    with open(fn, encoding='utf-8', errors='ignore') as ff:
        dd = ff.read()
        kvs.update(json.loads(dd))

    fs = f"from {fn} read {len(dd)} bytes"
    summ = f"{kvs[Cfg.N_SUMM]}, "
    collections = f"{len(kvs[Cfg.N_co])} collections"
    enumerations = f"{len(kvs[Cfg.N_e])} enumerations"
    classes = f"{len(kvs[Cfg.N_c])} classes"
    methods = f"{len(kvs[Cfg.N_c + '_' + Cfg.N_m])} methods"
    properties = f"{len(kvs[Cfg.N_c + '_' + Cfg.N_p])} properties"

    print(f"{fs}\n SUMMARY:  {summ}\n JSON loads:  {collections}, {enumerations}, {classes}, {methods}, {properties}.", file=sys.stderr)


def get_cln_class_comment(objinfo: dict) -> str | None:
    if objinfo:
        c_doc = objinfo.get(Cfg.N_c_doc)
        c_remarks_doc = objinfo.get(Cfg.N_c_remarks_doc)
        c_example_doc = objinfo.get(Cfg.N_c_example_doc)
        sss = []
        if c_doc:
            sss.append(c_doc)
        if c_remarks_doc:
            sss.append("#REMARKS:\n\n" + c_remarks_doc)
        if c_example_doc:
            sss.append("#EXAMPLE:\n\n" + c_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    return None


def get_cln_method_comment(objinfo: dict) -> str | None:
    if objinfo:
        m_doc = objinfo.get(Cfg.N_m_doc)
        m_return_doc = objinfo.get(Cfg.N_m_return_doc)
        m_parameters_doc = objinfo.get(Cfg.N_m_parameters_doc)
        m_remarks_doc = objinfo.get(Cfg.N_m_remarks_doc)
        m_example_doc = objinfo.get(Cfg.N_m_example_doc)
        sss = []
        if m_doc:
            sss.append(m_doc)
        if m_parameters_doc:
            sss.append('#PARAMETERS:\n\n' + m_parameters_doc)
        if m_return_doc:
            sss.append('#RETURN-VALUE: ' + m_return_doc)
        if m_remarks_doc:
            sss.append('#REMARKS:\n\n' + m_remarks_doc)
        if m_example_doc:
            sss.append('#EXAMPLE:\n\n' + m_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    return None


def get_cln_property_comment(objinfo: dict) -> str | None:
    if objinfo:
        p_doc = objinfo.get(Cfg.N_p_doc)
        p_syntax_doc = objinfo.get(Cfg.N_p_syntax_doc)
        p_return_doc = objinfo.get(Cfg.N_p_return_doc)
        p_property_value_doc = objinfo.get(Cfg.N_p_property_value_doc)
        p_remarks_doc = objinfo.get(Cfg.N_p_remarks_doc)
        p_example_doc = objinfo.get(Cfg.N_p_example_doc)
        sss = []
        if p_doc:
            sss.append(p_doc)
        if p_syntax_doc:
            sss.append('#SYNTAX:\n\n' + p_syntax_doc)
        if p_return_doc:
            sss.append('#RETRUN-VALUE: ' + p_return_doc)
        if p_property_value_doc:
            sss.append('#PROPERTY-VALUE: ' + p_property_value_doc)
        if p_remarks_doc:
            sss.append('#REMARKS:\n\n' + p_remarks_doc)
        if p_example_doc:
            sss.append('#EXAMPLE:\n\n' + p_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    return None


def conv2cls(cls_name: str,
             ole_info_kvs: dict,
             unfoundcls: set,
             ) -> tuple:
    '''from dict find cls attrs, methods, unknown properties, and errors'''
    cl_info_kvs = ole_info_kvs[Cfg.N_c][cls_name]
    Cfg.num += 1
    SP2 = ' ' * 2
    SP4 = SP2 * 2

    c_ns = []
    p_ns = []
    m_ns = []
    for na in sorted(cl_info_kvs.keys()):
        if na == Cfg.N_META:
            continue
        objinfo = cl_info_kvs[na]
        if dict != type(objinfo):
            continue
        if 'cic' in objinfo:
            c_ns.append(na)
        if Cfg.N_p_doc in objinfo:
            p_ns.append(na)
        elif Cfg.N_m_doc in objinfo:
            m_ns.append(na)
        else:
            print(f'unknown objinfo {objinfo.keys()}', file=sys.stderr)

    print(f" {cls_name} \t {len(p_ns) } {len(m_ns)}", file=sys.stderr)

    ofpyi = io.StringIO()
    ofpy = io.StringIO()
    if len(c_ns) > 0:
        Print1(f'{SP2}# {cls_name} cs', file=ofpyi)
        for na in c_ns:
            objinfo = cl_info_kvs[na]

        Print1(f'{SP2}# {cls_name} cs end', file=ofpyi)
        Print2(file1=ofpyi, file2=ofpy)

    if len(p_ns) > 0:
        Print1(f'{SP2}# {cls_name} ps', file=ofpyi)
        Print2(f'{SP2}def __init__(self):', file1=ofpyi, file2=ofpy)
        for na in p_ns:
            objinfo = cl_info_kvs[na]
            ty = objinfo[Cfg.N_p_type]
            if ty:
                for ii in ty.split('|'):
                    ii = ii.strip()
                    unfoundcls.add(ii)
            comments = get_cln_property_comment(objinfo)
            indsuff = f"\n{SP4}" if (comments and ('\n' in comments or comments[-1] in "'\"")) else ''
            comments = f"\n{SP4}'''{comments}{indsuff}'''\n" if comments else ''
            Print1(f"{SP4}self.{na}: {ty}{comments}", file=ofpyi)
            if ty is None or ty in Cfg.BUILTINS_CLASS:
                ty2 = f"{ty}"
            else:
                ty2 = f"None \t#{ty}"
            Print1(f"{SP4}self.{na}: {ty2}".expandtabs(12), file=ofpy)   # TODO
        Print1(f'{SP2}# {cls_name} ps end', file=ofpyi)
        Print2(file1=ofpyi, file2=ofpy)

    if len(m_ns) > 0:
        Print1(f'{SP2}# {cls_name} ns', file=ofpyi)
        for na in m_ns:
            objinfo = cl_info_kvs[na]
            ret = objinfo.get(Cfg.N_m_return)
            pars = objinfo.get(Cfg.N_m_parameters_as)
            if pars:
                ars = pars
            else:
                ars = []
            if ret is not None:
                if ret:
                    for ii in str(ret).split('|'):
                        ii = ii.strip()
                        unfoundcls.add(ii)
                rets = ' -> ' + str(ret)
            else:
                rets = ''
            comments = get_cln_method_comment(objinfo)
            indsuff = f"\n{SP4}" if (comments and ('\n' in comments or comments[-1] in "'\"")) else ''
            comments = f"\n{SP4}'''{comments}{indsuff}'''\n" if comments else '  ...\n'
            Print1(f"{SP2}def {na}(self, {', '.join(ars)}){rets}:{comments}", file=ofpyi)
            Print1(f"{SP2}def {na}(self, {', '.join(ars)}) -> None: pass \t#{ret}".expandtabs(22), file=ofpy)
        Print1(f'{SP2}# {cls_name} ns end', file=ofpyi)
        Print2(file1=ofpyi, file2=ofpy)

    var_methodssi = ofpyi.getvalue()
    var_methodss = ofpy.getvalue()
    ofpyi = io.StringIO()
    ofpy = io.StringIO()

    # class header
    Print2(f'class {cls_name}:', file1=ofpyi, file2=ofpy)
    comments = get_cln_class_comment(cl_info_kvs)
    if comments:
        indsuff = f"\n{SP2}" if ('\n' in comments or comments[-1] in "'\"") else ''
        Print1(f"{SP2}'''{comments}{indsuff}'''\n", file=ofpyi)
    Print1(f"{SP2}'''just need name'''", file=ofpy)
    Print2(file1=ofpyi, file2=ofpy)

    # var methods
    Print1(var_methodssi, file=ofpyi)
    Print1(var_methodss, file=ofpy)
    Print2(file1=ofpyi, file2=ofpy)

    # print(f'# Summary "{ex.__class__.__mro__}", attrs:{len(o_attrs)}, methods:{len(o_methods)}, unknowns:{len(o_unknowns)},   ok:{len(o_attrs) + len(o_methods) + len(o_unknowns)}, e_noattr:{len(e_noattr)}, e_eerror:{ len(e_ee)}', file=ofpyi)
    return (ofpyi.getvalue(), ofpy.getvalue())


def out_collection(ff, ole_info_kvs: dict):
    SP2 = ' ' * 2
    for k in ole_info_kvs[Cfg.N_co]:
        kvs: dict = ole_info_kvs[Cfg.N_co][k]
        print(f'class {k}:', file=ff)
        e_doc = kvs.get(Cfg.N_co_doc)
        sss = []
        if e_doc:
            sss.append(e_doc)
        comments = "\n\n".join(sss)
        indsuff = f'\n{SP2}' if ('\n' in comments or comments[-1] in "'\"") else ''
        print(f"{SP2}'''{comments}{indsuff}'''\n", file=ff)
    pass


def out_enumeration(ff, ole_info_kvs: dict):
    SP2 = ' ' * 2
    for k in ole_info_kvs[Cfg.N_e]:

        kvs: dict = ole_info_kvs[Cfg.N_e][k]

        if kvs.get(Cfg.N_e_unique):
            print(f'@unique', file=ff)
        print(f'class {k}(IntFlag):', file=ff)

        e_doc = kvs.get(Cfg.N_e_doc)
        e_remarks_doc = kvs.get(Cfg.N_e_remarks_doc)
        sss = []
        if e_doc:
            sss.append(e_doc)
        if e_remarks_doc:
            sss.append('#REMARKS:\n\n' + e_remarks_doc)
        comments = "\n\n".join(sss)
        indsuff = f'\n{SP2}' if ('\n' in comments or comments[-1] in "'\"") else ''
        print(f"{SP2}'''{comments}{indsuff}'''\n", file=ff)

        e_table_rows = kvs.get(Cfg.N_e_table_rows)
        if e_table_rows:
            for ii in e_table_rows:
                if not ii:
                    continue
                try:
                    n, v, desc = ii[0], ii[1], ii[2]
                    print(f"{SP2}{n} = {v}", file=ff)
                    print(
                        f"{SP2}'''{desc}{ '  '+' '.join([str(i) for i in ii[3:]]) if len(ii)>3 else '' }'''", file=ff)
                except:
                    print(f'ERR ii {ii}', file=sys.stderr)
        print(file=ff)
    pass


def out_collection_enumeration(ff, ole_info_kvs: dict) -> list:
    # out collection
    coks = ole_info_kvs[Cfg.N_co]
    print(f'# list collection  {len(coks)}', file=ff)
    out_collection(ff, ole_info_kvs)
    print(f'# list collection  end', file=ff)
    print(file=ff)

    # out enumeration
    eks = ole_info_kvs[Cfg.N_e]
    print(f'# list enumeration  {len(eks)}', file=ff)
    out_enumeration(ff, ole_info_kvs)
    print(f'# list enumeration  end', file=ff)
    print(file=ff)

    c = []
    c.extend(coks.keys())
    c.extend(eks.keys())
    return c


def Print1(*values, file):
    print(*values, file=file)


def Print2(*values, file1, file2):
    print(*values, file=file1)
    print(*values, file=file2)


def output_to_pyi_typehints(pyifn: str, pyfn: str, ole_info_kvs: dict):
    '''all_cls_kvs.each -->   output  to pyi file'''
    if ole_info_kvs:

        unfoundcls = set()

        ofpyi = io.StringIO()
        ofpy = io.StringIO()
        # defined cls
        clsns = sorted(ole_info_kvs[Cfg.N_c].keys())
        Print2(f'# ole cls  {len(clsns)}', file1=ofpyi, file2=ofpy)
        for clsn in clsns:
            clssi, clss = conv2cls(clsn, ole_info_kvs, unfoundcls)
            Print1(clssi, file=ofpyi)
            Print1(clss, file=ofpy)
        Print2(f'# ole cls end', file1=ofpyi, file2=ofpy)
        Print2(file1=ofpyi, file2=ofpy)

        strpyi = ofpyi.getvalue()
        strpy = ofpy.getvalue()
        ofpyi = io.StringIO()
        ofpy = io.StringIO()

        # file header
        Print2(Cfg.OUTFILE_HEADER, file1=ofpyi, file2=ofpy)
        Print2(file1=ofpyi, file2=ofpy)
        Print2(Cfg.IMPORTS, file1=ofpyi, file2=ofpy)
        Print2(file1=ofpyi, file2=ofpy)

        coeks = out_collection_enumeration(ofpyi, ole_info_kvs)
        out_collection_enumeration(ofpy, ole_info_kvs)
        Print2(file1=ofpyi, file2=ofpy)

        # unfoundcls
        nns = sorted([str(i) for i in unfoundcls])
        Print2(f'# unfoundcls', file1=ofpyi, file2=ofpy)
        for cls_name in nns:
            if not cls_name:
                continue
            if '.' not in cls_name:
                if cls_name in Cfg.BUILTINS_CLASS or cls_name in clsns or cls_name in coeks:
                    continue
                Print2(f'class {cls_name}: pass', file1=ofpyi, file2=ofpy)
            else:
                continue # TODO FIXME SKIP
                if cls_name[0] in 'abcdefghijklmnopqrstuvwxyz':
                    continue
                nss = cls_name.split('.')
                indi = 0
                for i in range(len(nss)-1):
                    cls_name = nss[i]
                    if cls_name in Cfg.BUILTINS_CLASS:
                        continue
                    Print2(f'{" "*indi}class {cls_name}:', file1=ofpyi, file2=ofpy)
                    indi += 2
                Print2(f'{" "*indi}class {nss[-1]}: pass', file1=ofpyi, file2=ofpy)
        Print2(f'# unfoundcls  end', file1=ofpyi, file2=ofpy)
        Print2(file1=ofpyi, file2=ofpy)

        # get def cls
        Print1(strpyi, file=ofpyi)
        Print1(strpy, file=ofpy)
        Print2(file1=ofpyi, file2=ofpy)

        # output all define
        with open(pyifn, 'w', encoding='utf-8') as fpyi, open(pyfn, 'w', encoding='utf-8') as fpy:
            print(ofpyi.getvalue(), file=fpyi)
            print(ofpy.getvalue(), file=fpy)


# ------------------------------------------------------------------------


def runit():
    ole_info_kvs: dict[str, str] = {}

    load_info_from_json(Cfg.OUT_EXCEL_INFO_FN, ole_info_kvs)
    print('------------------------------------------', file=sys.stderr)

    output_to_pyi_typehints(Cfg.OUT_EXCEL_PYI_FN, Cfg.OUT_EXCEL_PY_FN, ole_info_kvs)


if __name__ == '__main__':
    check_or_exit()
    runit()
