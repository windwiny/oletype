import inspect
import io
import json
import os.path
import re
import sys
from win32com.client import CDispatch, Dispatch


class Cfg():
    ''' TODO'''
    num = 0

    N_c = 'classes'
    N_c_c = 'class'
    N_m = 'methods'
    N_m_m = 'method'
    N_m_r = 'return'
    N_p = 'properties'
    N_p_t = 'type'
    N_p_i = 'info'

    excel_info_fn = 'excel.info.json'
    out_pyfile_fn = 'oletype/excel.py'

    mypkgname = 'excel.'
    mypkgname = ''

    # python \Python311\Lib\site-packages\win32com\client\makepy.py
    #  Generating to C:\Users\user1\AppData\Local\Temp\gen_py\3.11\00020813-0000-0000-C000-000000000046x0x1x9.py
    # autoclsn: str = "<class 'win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    # autoclsn2: str = "win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    win32comclsn: str = "<class 'win32com."

    HEADER = '''
# Generated by oletype, win32com(excel) object py/pyi file
#   for ide tips
#
# Usage:
#   from win32com.client import Dispatch
#   from oletype import excel
#   exapp = excel.Application = Dispatch('excel.application')  #declare app obj
#   exapp.   #  get ide auto type hit

'''


def check_or_exit():
    if not os.path.exists(Cfg.excel_info_fn):
        print(f'not exists method comment file {Cfg.excel_info_fn}')
        sys.exit(2)


def load_info_from_json(fn: str, kvs: dict):
    with open(fn, encoding='utf-8', errors='ignore') as ff:
        dd = ff.read()
        kvs.update(json.loads(dd))
    fs = f'''from {fn} read {len(dd)} bytes'''
    classes = f'''load {len(kvs[Cfg.N_c])} classes info'''
    methods = f'''load {len(kvs[Cfg.N_m])} methods info'''
    properties = f'''load {len(kvs['properties'])} properties info'''
    print(f'''{fs}, {classes}, {methods}, {properties}.''', file=sys.stderr)


def get_cln_class_comment(cln: str,
                          ole_type_kvs: dict,
                          ) -> str | None:
    key = Cfg.N_c
    objinfo = ole_type_kvs[key].get(cln)
    if objinfo:
        return objinfo.get(Cfg.N_c_c)
    return None


def get_cln_property_info(cln: str,
                          member: str,
                          ole_type_kvs: dict,
                          all_see_cls: set,
                          ) -> str | None:
    key = Cfg.N_p
    objinfo = ole_type_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        return objinfo.get(Cfg.N_p_i)
    return None


def get_cln_property_type(cln: str,
                          member: str,
                          ole_type_kvs: dict,
                          all_see_cls: set,
                          ) -> str | None:
    key = Cfg.N_p
    objinfo = ole_type_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        ty = objinfo.get(Cfg.N_p_t)
        if ty == 'null':
            ty = 'TYPE_NULL'
            all_see_cls.add(ty)
        if ' ' in ty:
            ty = 'TYPE_NO_RECOGNITION_FROM_STRING'
            all_see_cls.add(ty)
        if '.' in ty:
            ty = ty.split('.')[-1]
        if not ty in dir(__builtins__) and not ty in all_see_cls:
            all_see_cls.add(ty)
        return ty
    return None


def get_cln_method_comment(cln: str,
                           member: str,
                           ole_type_kvs: dict,
                           ) -> str | None:
    key = Cfg.N_m
    objinfo = ole_type_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        return objinfo.get(Cfg.N_m_m)
    return None


def get_cln_method_return(cln: str,
                          member: str,
                          all_see_cls: set,
                          unparsed_cls: set,
                          ole_type_kvs: dict,
                          ) -> str | None:
    key = Cfg.N_m
    objinfo = ole_type_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        objtype = objinfo.get(Cfg.N_m_r)
        if objtype == '' or objtype is None:
            return None
        elif objtype == 'None':
            return 'None'

        # re1 = re.compile(r' \t~`!@#$%^&*()+-={}[]\\|;\':"<>,./?')  # no _
        # re1 = re.compile('[\ \t\~\`\!\@\#\$\%\^\&\*\(\)\+\-\=\{\}\[\]\\\|\;\'\:\"\<\>\,\.\/\?]')
        re1 = re.compile('\W')
        objtype2 = re1.sub('_', objtype)
        if objtype2 != objtype:
            objtype = objtype2
            unparsed_cls.add(objtype)
            return objtype
        else:
            if objtype not in dir(__builtins__):
                all_see_cls.add(objtype)
            return objtype

    return None


def conv2cls(ex: CDispatch,
             cls_name: str,
             o_attrs: list[tuple],
             o_methods: list[tuple],
             o_unknowns: list[tuple],
             e_noattr: list[tuple],
             e_ee: list[tuple],
             all_see_cls: set,
             unparsed_cls: set,
             ole_type_kvs: dict,
             ) -> str:
    '''from dict find cls attrs, methods, unknown properties, and errors'''
    Cfg.num += 1

    ff = io.StringIO()
    print(file=ff)
    print(f'# num={Cfg.num}', file=ff)
    print(f'class {cls_name}:', file=ff)
    cls_comment = get_cln_class_comment(cls_name, ole_type_kvs)
    if cls_comment:
        print(f"""  '''{cls_comment}'''""", file=ff)

    print('  def __init__(self):', file=ff)
    for ix in o_attrs:
        na, ty = ix
        if ty:
            ty = str(ty).replace("<class '", '').replace("'>", '').split('.')[-1]
            if ty:
                ty = Cfg.mypkgname + ty
            else:
                ty = 'TYPE_EMPTY'
                all_see_cls.add(ty)
        else:
            ty = 'TYPE_UNKNOWN'
            all_see_cls.add(ty)
        comment_or_pass = get_cln_property_info(cls_name, na, ole_type_kvs, all_see_cls)
        comment_or_pass = f"\n    '''{comment_or_pass}'''" if comment_or_pass else ''
        print(f"    self.{na}: {ty}{comment_or_pass}", file=ff)
    print(file=ff)

    for ix in o_methods:
        na, vv = ix
        s = inspect.signature(vv)
        ars = []
        for v1, v2 in s.parameters.items():
            ars.append(f"{v1}")  # :{v1}
        ars = ", ".join(ars)
        ret = s.return_annotation
        ret = str(ret)
        ret = ret.replace("<class '", '').replace("'>", '')
        if ret == 'inspect._empty':
            ret = get_cln_method_return(cls_name, na, all_see_cls, unparsed_cls, ole_type_kvs)
        else:
            pass
        if ret is not None:
            rets = ' -> ' + str(ret)
        else:
            rets = ''
        comment_or_pass = get_cln_method_comment(cls_name, na, ole_type_kvs)
        comment_or_pass = f"\n    '''{comment_or_pass}'''" if comment_or_pass else '  pass'
        print(f"  def {na}(self{(', ' + ars) if ars else ''}){rets}:{comment_or_pass}", file=ff)
    print(file=ff)

    print(f'  #unknown:', file=ff)
    for ix in o_unknowns:
        na, ee = ix
        print(f"    # {na}:  {ee}", file=ff)
    print(file=ff)

    print(f"  #getattr AttributeError:", file=ff)
    for ix in e_noattr:
        na, ee = ix
        print(f"    # {na}:  {ee}", file=ff)
    print(file=ff)

    print(f"  #getattr Exception:", file=ff)
    for ix in e_ee:
        na, ee = ix
        print(f"    # {na}:  {ee}", file=ff)
    print(file=ff)
    print(f'# Summary "{ex.__class__.__mro__}", attrs:{len(o_attrs)}, methods:{len(o_methods)}, whats:{len(o_unknowns)},   ok:{len(o_attrs) + len(o_methods) + len(o_unknowns)}, er:{len(e_noattr)}, er:{ len(e_ee)}', file=ff)
    return ff.getvalue()


def showinfo(cls_name: str,
             ex: CDispatch,
             all_cls: dict,
             already_pr: set,
             all_see_cls: set,
             unparsed_cls: set,
             ole_type_kvs: dict,
             ) -> str:
    '''dir ex, show info'''

    if cls_name in already_pr:
        # print(f'### SKIP pred {cls_name}\n', file=sys.stderr)
        return ''
    else:
        already_pr.add(cls_name)
        # print(f'\n### SHOWINFO {cls_name}', file=sys.stderr)

    objxx = [repr(i) for i in dir(object())]
    xx = dir(ex)
    o_attrs = []
    o_methods = []
    o_unknowns = []
    e_noattr = []
    e_ee = []
    for i in xx:
        if repr(i) in objxx:
            continue
        try:
            # ex.__getattr__(i)
            vv = getattr(ex, i)
            typevv = type(vv)

            if str(typevv) == "<class 'method'>":
                o_methods.append((i, vv))
            elif str(typevv).startswith(Cfg.win32comclsn):
                clsn = str(typevv).replace("<class '", '').replace("'>", '').split('.')[-1]
                all_cls[clsn] = vv
                o_attrs.append((i, typevv))
            elif f'{cls_name}.{i}' in ole_type_kvs['properties']:
                o_attrs.append((i, get_cln_property_type(cls_name, i, ole_type_kvs, all_see_cls)))
            elif typevv in [bool, str, int, float, dict, tuple]:
                if i in ['Value', 'Value2'] and cls_name in ['Range']:
                    # TODO FIXME, same parameter return type any
                    # print(f'xxx2 {cls_name}.{i} {str(vv)}  {typevv} ', file=sys.stderr)
                    typevv = 'VBA_Variant'
                o_attrs.append((i, typevv))
            else:
                o_unknowns.append((i, typevv))
        except AttributeError:
            e_noattr.append(i)
        except Exception as e:
            e_ee.append((i, e))

    cls_def_str = conv2cls(ex, cls_name, o_attrs, o_methods, o_unknowns, e_noattr, e_ee,
                           all_see_cls, unparsed_cls, ole_type_kvs)
    return cls_def_str


def print_ole_empty(ff, ole_type_kvs, has_defstr_cls):
    ocls = ole_type_kvs[Cfg.N_c].keys()
    print(f'# ole empty class.  {len(set(ocls).difference(has_defstr_cls))}', file=ff)
    for i in sorted(ocls):
        if i not in has_defstr_cls:
            print(f'class {i}: pass', file=ff)
    print(file=ff)


def output_all_cls_pyi(all_cls: dict[str, any],
                       unparsed_cls: set,
                       has_defstr_cls: set,
                       all_cls_def_strs: list,
                       all_see_cls: set,
                       ole_type_kvs: dict,
                       ):
    '''all_cls.each -->   output  to pyi file'''
    ff = io.StringIO()

    # head
    print(Cfg.HEADER, file=ff)
    print(file=ff)

    # output all unparsed type
    print(f'# TODO FIXME unparsed types.  {len(unparsed_cls)}', file=ff)
    for i in sorted(unparsed_cls):
        print(f'class {i}: pass', file=ff)
    print(file=ff)

    # output all all_see_cls - has_defstr_cls
    ocls = ole_type_kvs[Cfg.N_c].keys()
    print(f'# TODO FIXME not found types.  {len(set(all_see_cls).difference(has_defstr_cls).difference(ocls))}', file=ff)
    for i in sorted(all_see_cls):
        if i not in has_defstr_cls and not i in ocls:
            print(f'class {i}: pass', file=ff)
    print(file=ff)

    # output ole empty class
    print_ole_empty(ff, ole_type_kvs, has_defstr_cls)

    # print each class define
    print(f'# list all_cls_def_strs  {len(all_cls_def_strs)}', file=ff)
    for i in range(len(all_cls_def_strs)):
        data = all_cls_def_strs[i]  # order or reverse
        print(data, file=ff)

    print(f'## PRINT  {len(all_cls)}\n', file=sys.stderr)

    # get all
    data = ff.getvalue()

    # replace CoCobase
    hasbaseclss = list(filter(lambda x: True if x[0] == '_' else False, all_cls.keys()))
    for _base in hasbaseclss:
        cls = _base[1:]
        data = data.replace(f'class {cls}:', f'class {cls}({_base}):')

    # output all define
    print(data)

    print('all cls', len(all_cls), sorted(all_cls.keys()), file=sys.stderr)
    print('base cls', len(hasbaseclss), sorted(hasbaseclss), file=sys.stderr)


def output_all_cls_pyfake(fn: str,
                          all_cls: dict[str, CDispatch],
                          has_defstr_cls: set,
                          ole_type_kvs: dict
                          ):
    '''all_cls.each -> "class XX: pass"'''
    with open(fn, 'w') as ff:
        print(Cfg.HEADER, file=ff)

        print(f'# all_cls {len(all_cls)}', file=ff)
        for cl in all_cls:
            print(f'class {cl}: pass', file=ff)

        print(file=ff)
        print_ole_empty(ff, ole_type_kvs, has_defstr_cls)
    print(f'output to py class info file: {fn}', file=sys.stderr)


# ------------------------------------------------------------------------


def runit():
    all_see_cls: set = set()
    has_defstr_cls: set = set()
    unparsed_cls: set = set()
    ole_type_kvs: dict[str, str] = {}

    all_cls: dict[str, CDispatch] = {}
    already_pr: set[str] = set()

    all_cls_def_strs: list[str] = []

    load_info_from_json(Cfg.excel_info_fn, ole_type_kvs)
    print('------------------------------------------', file=sys.stderr)

    exapp = Dispatch('excel.application')
    exapp.Visible = True

    wb = exapp.Workbooks.Add()
    ws = exapp.ActiveSheet
    ws.Range("A1:B3").Value = [[2, 4], [5, 6], [4, 6]]
    ws.Shapes.AddChart()

    cls_name = 'Application'
    all_cls[cls_name] = exapp

    for i in range(10000):
        if all_cls.keys() == already_pr:
            print(f"## ALL DONE at {i}", file=sys.stderr)
            break
        for clsn in list(all_cls):
            exx = all_cls[clsn]
            cls_def_str = showinfo(clsn, exx, all_cls, already_pr, all_see_cls,
                                   unparsed_cls, ole_type_kvs)
            # print(f'for {i}   {clsn}  {len(cls_def_str)}', file=sys.stderr)
            if cls_def_str:
                has_defstr_cls.add(clsn)
                all_cls_def_strs.append(cls_def_str)
    print('------------------------------------------', file=sys.stderr)

    output_all_cls_pyi(all_cls, unparsed_cls, has_defstr_cls, all_cls_def_strs, all_see_cls, ole_type_kvs)
    output_all_cls_pyfake(Cfg.out_pyfile_fn, all_cls, has_defstr_cls, ole_type_kvs)

    ws.Name = 'test'
    wb.Saved = True


if __name__ == '__main__':
    check_or_exit()
    runit()
