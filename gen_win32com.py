# coding: utf-8
import inspect
import io
import json
import os.path
import pprint
import re
import sys
from win32com.client import CDispatch, Dispatch


class Cfg():
    '''Config TODO  sync rb/py file'''
    OUT_EXCEL_INFO_FN = "excel.info.json"

    N_SUMM = "summary"

    N_co = "collections"
    N_co_doc = "co_doc"

    N_e = "enumerations"
    N_e_unique = "uniqued"
    N_e_doc = "e_doc"
    N_e_table_head = "e_table_head"
    N_e_table_rows = "e_table_rows"
    N_e_remarks_doc = "e_remarks_doc"
    N_e_table_format_incorrect = "e_ERROR"

    N_c = "classes"
    N_c_doc = "c_doc"
    N_c_remarks_doc = "c_remarks_doc"
    N_c_example_doc = "c_examples_doc"

    N_m = "methods"
    N_m_doc = "m_doc"
    N_m_return = "m_return"
    N_m_return_doc = "m_return_doc"
    N_m_parameters_doc = "m_parameters_doc"
    N_m_remarks_doc = "m_remarks_doc"
    N_m_example_doc = "m_example_doc"

    N_p = "properties"
    N_p_doc = "p_doc"
    N_p_type = "p_type"
    N_p_syntax_doc = "p_syntax_doc"
    N_p_return_doc = "p_return_doc"
    N_p_property_value_doc = "p_property_value_doc"
    N_p_remarks_doc = "p_remarks_doc"
    N_p_example_doc = "p_example_doc"

    OUT_EXCEL_PYI_FN = "oletype/excel.pyi"
    OUT_EXCEL_PY_FN = "oletype/excel.py"
    MYPKGNAME = "excel."
    MYPKGNAME = ""

    # python \Python311\Lib\site-packages\win32com\client\makepy.py
    #  Generating to C:\Users\user1\AppData\Local\Temp\gen_py\3.11\00020813-0000-0000-C000-000000000046x0x1x9.py
    # ole_class_pre: str = "<class 'win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    # ole_class_pre2: str = "win32com.gen_py.00020813-0000-0000-C000-000000000046x0x1x9."
    OLE_CLASS_PRE: str = "<class 'win32com."

    BUILTINS_CLASS = [clsn for clsn in dir(__builtins__) if type(getattr(__builtins__, clsn)) == type]
    BUILTINS_CLASS.append('None')
    OBJECT_PROPERTIES = [repr(i) for i in dir(object())]
    OLEOBJECT_SKIP_PROPERTY = ['CLSID', '__weakref__', '_oleobj_', 'coclass_clsid']
    OLEOBJECT_SKIP_EXCEPTION_PROPERTY = ['Visible']

    OUTFILE_HEADER = '''
# Generated by oletype, win32com(excel) object py/pyi file
#   for ide tips
#
# Usage:
#   from win32com.client import Dispatch
#   from oletype import excel
#   exapp = excel.Application = Dispatch('excel.application')  #declare app obj
#   exapp.   #  get ide auto type hit
'''
    IMPORTS = '''
from enum import IntFlag, IntEnum, unique
'''
    num = 0
    type_diff = {}


def check_or_exit():
    if not os.path.exists(Cfg.OUT_EXCEL_INFO_FN):
        print(f'not exists info.json file {Cfg.OUT_EXCEL_INFO_FN}')
        sys.exit(2)


def load_info_from_json(fn: str, kvs: dict):
    with open(fn, encoding='utf-8', errors='ignore') as ff:
        dd = ff.read()
        kvs.update(json.loads(dd))

    fs = f"from {fn} read {len(dd)} bytes"
    summ = f"{kvs[Cfg.N_SUMM]}, "
    collections = f"{len(kvs[Cfg.N_co])} collections"
    enumerations = f"{len(kvs[Cfg.N_e])} enumerations"
    classes = f"{len(kvs[Cfg.N_c])} classes"
    methods = f"{len(kvs[Cfg.N_m])} methods"
    properties = f"{len(kvs[Cfg.N_p])} properties"

    print(f"{fs}\n SUMMARY:  {summ}\n JSON loads:  {collections}, {enumerations}, {classes}, {methods}, {properties}.", file=sys.stderr)


def get_cln_class_comment(cln: str,
                          ole_info_kvs: dict,
                          ) -> str | None:
    key = Cfg.N_c
    objinfo = ole_info_kvs[key].get(cln)
    Cfg.type_diff[cln] = iffo = { }
    if objinfo:
        if Cfg.N_c_doc not in objinfo:
            iffo['no c_doc'] = object.keys()
        c_doc = objinfo.get(Cfg.N_c_doc)
        c_remarks_doc = objinfo.get(Cfg.N_c_remarks_doc)
        c_example_doc = objinfo.get(Cfg.N_c_example_doc)
        sss = []
        if c_doc:
            sss.append(c_doc)
        if c_remarks_doc:
            sss.append("#REMARKS:\n\n" + c_remarks_doc)
        if c_example_doc:
            sss.append("#EXAMPLE:\n\n" + c_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    else:
        iffo['no_c'] = True
    return None


def get_cln_method_comment(cln: str,
                           member: str,
                           ole_info_kvs: dict,
                           ) -> str | None:
    key = Cfg.N_m
    objinfo = ole_info_kvs[key].get(f'{cln}.{member}')
    Cfg.type_diff[f'{cln}.{member} m'] = iffo = {  }
    if objinfo:
        if  Cfg.N_m_doc not in objinfo:
            iffo['no m_doc'] = object.keys()
        m_doc = objinfo.get(Cfg.N_m_doc)
        m_return_doc = objinfo.get(Cfg.N_m_return_doc)
        m_parameters_doc = objinfo.get(Cfg.N_m_parameters_doc)
        m_remarks_doc = objinfo.get(Cfg.N_m_remarks_doc)
        m_example_doc = objinfo.get(Cfg.N_m_example_doc)
        sss = []
        if m_doc:
            sss.append(m_doc)
        if m_parameters_doc:
            sss.append('#PARAMETERS:\n\n' + m_parameters_doc)
        if m_return_doc:
            sss.append('#RETURN-VALUE: ' + m_return_doc)
        if m_remarks_doc:
            sss.append('#REMARKS:\n\n' + m_remarks_doc)
        if m_example_doc:
            sss.append('#EXAMPLE:\n\n' + m_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    else:
        iffo['no m'] = True
    return None


def get_cln_method_return(cln: str,
                          member: str,
                          all_see_cls: set,
                          unparsed_cls: set,
                          ole_info_kvs: dict,
                          ) -> str | None:
    key = Cfg.N_m
    objinfo = ole_info_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        if not Cfg.N_m_return in objinfo:
            return None
        objtype = objinfo.get(Cfg.N_m_return)

        if '|' in objtype:
            return objtype

        if objtype == 'None' or objtype is None:    # return None may is not found on doc, 'None' then return Nothing
            return 'None'

        # re1 = re.compile(r' \t~`!@#$%^&*()+-={}[]\\|;\':"<>,./?')  # no _
        # re1 = re.compile('[\ \t\~\`\!\@\#\$\%\^\&\*\(\)\+\-\=\{\}\[\]\\\|\;\'\:\"\<\>\,\.\/\?]')
        # re1 = re.compile('\W')
        # objtype2 = re1.sub('_', objtype)
        # if objtype2 != objtype:
        #     objtype = objtype2
        #     unparsed_cls.add(objtype)
        if ' ' in objtype:
            if '|' in objtype:
                for x in objtype.split('|'):
                    x = x.strip()
                    if x not in Cfg.BUILTINS_CLASS:
                        all_see_cls.add(x)
                return objtype
            else:
                objtype = '__RETURN_TYPE_NO_RECOGNITION_FROM_STRING'
                all_see_cls.add(objtype)
        else:
            if objtype not in Cfg.BUILTINS_CLASS:
                all_see_cls.add(objtype)
        return objtype

    return None


def get_cln_property_comment(cln: str,
                             member: str,
                             ole_info_kvs: dict,
                             all_see_cls: set,
                             ) -> str | None:
    key = Cfg.N_p
    objinfo = ole_info_kvs[key].get(f'{cln}.{member}')
    Cfg.type_diff[f'{cln}.{member} p'] = iffo = {  }
    if objinfo:
        if Cfg.N_p_doc not in objinfo:
            iffo['no p_doc'] = object.keys()
        p_doc = objinfo.get(Cfg.N_p_doc)
        p_syntax_doc = objinfo.get(Cfg.N_p_syntax_doc)
        p_return_doc = objinfo.get(Cfg.N_p_return_doc)
        p_property_value_doc = objinfo.get(Cfg.N_p_property_value_doc)
        p_remarks_doc = objinfo.get(Cfg.N_p_remarks_doc)
        p_example_doc = objinfo.get(Cfg.N_p_example_doc)
        sss = []
        if p_doc:
            sss.append(p_doc)
        if p_syntax_doc:
            sss.append('#SYNTAX:\n\n' + p_syntax_doc)
        if p_return_doc:
            sss.append('#RETRUN-VALUE: ' + p_return_doc)
        if p_property_value_doc:
            sss.append('#PROPERTY-VALUE: ' + p_property_value_doc)
        if p_remarks_doc:
            sss.append('#REMARKS:\n\n' + p_remarks_doc)
        if p_example_doc:
            sss.append('#EXAMPLE:\n\n' + p_example_doc)
        sss = '\n\n'.join(sss)
        if sss and sss[-1] in "'\"":
            sss += ' '
        return sss
    else:
        iffo['no p'] = True
    return None


def get_cln_property_type(cln: str,
                          member: str,
                          ole_info_kvs: dict,
                          all_see_cls: set,
                          ) -> str | None:
    key = Cfg.N_p
    objinfo = ole_info_kvs[key].get(f'{cln}.{member}')
    if objinfo:
        ty = objinfo.get(Cfg.N_p_type)
        if ty == 'null':
            ty = '__TYPE_NULL'
            all_see_cls.add(ty)
        if ' ' in ty:
            if '|' in ty:
                for x in ty.split('|'):
                    x = x.strip()
                    if x not in Cfg.BUILTINS_CLASS:
                        all_see_cls.add(x)
                return ty
            else:
                ty = '__TYPE_NO_RECOGNITION_FROM_STRING'
                all_see_cls.add(ty)
        if '.' in ty:
            ty = ty.split('.')[-1]
        if not ty in Cfg.BUILTINS_CLASS:
            all_see_cls.add(ty)
        return ty
    return None


def out_list(comm: str, xx_attrs: list, ff):
    if not xx_attrs:
        return
    print(comm, file=ff)
    for ix in xx_attrs:
        na, ee = ix
        print(f"    # {na}:  {ee}", file=ff)
    print(file=ff)


def conv2cls(ex: CDispatch,
             cls_name: str,
             o_attrs: list[tuple],
             o_methods: list[tuple],
             o_unknowns: list[tuple],
             e_noattr: list[tuple],
             e_ee: list[tuple],
             all_see_cls: set,
             unparsed_cls: set,
             ole_info_kvs: dict,
             ) -> str:
    '''from dict find cls attrs, methods, unknown properties, and errors'''
    Cfg.num += 1

    ff = io.StringIO()
    print(file=ff)
    # print(f'# num={Cfg.num}', file=ff)
    print(f'class {cls_name}:', file=ff)
    comments = get_cln_class_comment(cls_name, ole_info_kvs)
    if comments:
        ind = '  '
        indsuff = f"\n{ind}" if ('\n' in comments or comments[-1] in "'\"") else ''
        print(f"{ind}'''{comments}{indsuff}'''\n", file=ff)

    print('  def __init__(self):', file=ff)
    for ix in o_attrs:
        na, ty = ix
        if ty:
            ty = str(ty).replace("<class '", '').replace("'>", '').split('.')[-1]
            if ty:
                ty = Cfg.MYPKGNAME + ty
            else:
                ty = '__TYPE_EMPTY'
                all_see_cls.add(ty)
        else:
            ty = '__TYPE_UNKNOWN'
            all_see_cls.add(ty)
        comments = get_cln_property_comment(cls_name, na, ole_info_kvs, all_see_cls)
        ind = '    '
        indsuff = f"\n{ind}" if (comments and ('\n' in comments or comments[-1] in "'\"")) else ''
        comments = f"\n{ind}'''{comments}{indsuff}'''\n" if comments else ''
        print(f"    self.{na}: {ty}{comments}", file=ff)
    print(file=ff)

    for ix in o_methods:
        na, vv = ix
        s = inspect.signature(vv)
        ars = []
        for v1, v2 in s.parameters.items():
            ars.append(f"{v1}")  # :{v1}
        ars = ", ".join(ars)
        ret = s.return_annotation
        ret = str(ret)
        ret = ret.replace("<class '", '').replace("'>", '')
        if ret == 'inspect._empty':
            ret = get_cln_method_return(cls_name, na, all_see_cls, unparsed_cls, ole_info_kvs)
        else:
            pass
        if ret is not None:
            rets = ' -> ' + str(ret)
        else:
            rets = ''
        comments = get_cln_method_comment(cls_name, na, ole_info_kvs)
        ind = '    '
        indsuff = f"\n{ind}" if (comments and ('\n' in comments or comments[-1] in "'\"")) else ''
        comments = f"\n{ind}'''{comments}{indsuff}'''\n" if comments else '  pass\n'
        print(f"  def {na}(self{(', ' + ars) if ars else ''}){rets}:{comments}", file=ff)
    print(file=ff)

    out_list("  #unknown:", o_unknowns, ff)
    out_list("  #getattr AttributeError:", e_noattr, ff)
    out_list("  #getattr Exception:", e_ee, ff)

    # print(f'# Summary "{ex.__class__.__mro__}", attrs:{len(o_attrs)}, methods:{len(o_methods)}, unknowns:{len(o_unknowns)},   ok:{len(o_attrs) + len(o_methods) + len(o_unknowns)}, e_noattr:{len(e_noattr)}, e_eerror:{ len(e_ee)}', file=ff)
    return ff.getvalue()


def showinfo(cls_name: str,
             ex: CDispatch,
             all_cls_kvs: dict,
             already_pr_cls: set,
             all_see_cls: set,
             unparsed_cls: set,
             ole_info_kvs: dict,
             ) -> str:
    '''dir ex, show info'''

    if cls_name in already_pr_cls:
        # print(f'### SKIP pred {cls_name}\n', file=sys.stderr)
        return ''
    else:
        already_pr_cls.add(cls_name)
        # print(f'\n### SHOWINFO {cls_name}', file=sys.stderr)

    xx = dir(ex)
    o_attrs = []
    o_methods = []
    o_unknowns = []
    e_noattr = []
    e_ee = []
    for i in xx:
        if i in Cfg.OLEOBJECT_SKIP_PROPERTY:
            continue
        if repr(i) in Cfg.OBJECT_PROPERTIES:
            continue
        try:
            # ex.__getattr__(i)
            vv = getattr(ex, i)
            typevv = type(vv)

            if str(typevv) == "<class 'method'>":
                o_methods.append((i, vv))
            elif str(typevv).startswith(Cfg.OLE_CLASS_PRE):
                clsn = str(typevv).replace("<class '", '').replace("'>", '').split('.')[-1]
                all_cls_kvs[clsn] = vv
                o_attrs.append((i, typevv))
            elif f'{cls_name}.{i}' in ole_info_kvs[Cfg.N_p]:
                o_attrs.append((i, get_cln_property_type(cls_name, i, ole_info_kvs, all_see_cls)))
            elif typevv in [bool, str, int, float, dict, tuple]:
                o_attrs.append((i, typevv))
            else:
                o_unknowns.append((i, typevv))
        except AttributeError:
            e_noattr.append(i)
        except Exception as e:
            if i not in Cfg.OLEOBJECT_SKIP_EXCEPTION_PROPERTY:
                e_ee.append((i, e))

    cls_def_str = conv2cls(ex, cls_name, o_attrs, o_methods, o_unknowns, e_noattr, e_ee,
                           all_see_cls, unparsed_cls, ole_info_kvs)
    return cls_def_str


def print_ole_empty(ff, ole_info_kvs, ole_cls_def_ns):
    ocls = ole_info_kvs[Cfg.N_c].keys()
    print(f'# ole empty class.  {len(set(ocls).difference(ole_cls_def_ns))}', file=ff)
    for i in sorted(ocls):
        if i not in ole_cls_def_ns:
            print(f'class {i}: pass', file=ff)
    print(file=ff)


def out_collection(ff, ole_info_kvs: dict):
    for k in ole_info_kvs[Cfg.N_co]:
        kvs: dict = ole_info_kvs[Cfg.N_co][k]
        print(f'class {k}:', file=ff)
        e_doc = kvs.get(Cfg.N_co_doc)
        sss = []
        if e_doc:
            sss.append(e_doc)
        comments = "\n\n".join(sss)
        ind = '  '
        indsuff = f'\n{ind}' if ('\n' in comments or comments[-1] in "'\"") else ''
        print(f"{ind}'''{comments}{indsuff}'''\n", file=ff)
    pass


def out_enumeration(ff, ole_info_kvs: dict):
    for k in ole_info_kvs[Cfg.N_e]:

        kvs: dict = ole_info_kvs[Cfg.N_e][k]

        if kvs.get(Cfg.N_e_unique):
            print(f'@unique', file=ff)
        print(f'class {k}(IntFlag):', file=ff)

        e_doc = kvs.get(Cfg.N_e_doc)
        e_remarks_doc = kvs.get(Cfg.N_e_remarks_doc)
        sss = []
        if e_doc:
            sss.append(e_doc)
        if e_remarks_doc:
            sss.append('#REMARKS:\n\n' + e_remarks_doc)
        comments = "\n\n".join(sss)
        ind = '  '
        indsuff = f'\n{ind}' if ('\n' in comments or comments[-1] in "'\"") else ''
        print(f"{ind}'''{comments}{indsuff}'''\n", file=ff)

        e_table_rows = kvs.get(Cfg.N_e_table_rows)
        for ii in e_table_rows:
            if not ii:
                continue
            try:
                n, v, desc = ii[0], ii[1], ii[2]
                print(f"  {n} = {v}", file=ff)
                print(
                    f"  '''{desc}{ '  '+' '.join([str(i) for i in ii[3:]]) if len(ii)>3 else '' }'''", file=ff)
            except:
                print(f'ERR ii {ii}', file=sys.stderr)
        print(file=ff)
    pass


def out_collection_enumeration(ff, ole_info_kvs: dict):
    # out collection
    print(f'# list collection  {len(ole_info_kvs[Cfg.N_co])}', file=ff)
    out_collection(ff, ole_info_kvs)
    print(file=ff)

    # out enumeration
    print(f'# list enumeration  {len(ole_info_kvs[Cfg.N_e])}', file=ff)
    out_enumeration(ff, ole_info_kvs)
    print(file=ff)


def output_to_pyi_typehints(fn: str,
                            all_cls_kvs: dict[str, any],
                            unparsed_cls: set,
                            ole_cls_def_ns: set,
                            ole_cls_defstrs: list,
                            all_see_cls: set,
                            ole_info_kvs: dict,
                            ):
    '''all_cls_kvs.each -->   output  to pyi file'''
    ff = io.StringIO()

    # head
    print(Cfg.OUTFILE_HEADER, file=ff)
    print(file=ff)
    print(Cfg.IMPORTS, file=ff)
    print(file=ff)

    # output all unparsed type
    print(f'# TODO FIXME unparsed types.  {len(unparsed_cls)}', file=ff)
    for i in sorted(unparsed_cls):
        print(f'class {i}: pass', file=ff)
    print(file=ff)

    # output all all_see_cls - ole_cls_def_ns
    ocls = ole_info_kvs[Cfg.N_c].keys()
    oenums = ole_info_kvs[Cfg.N_e].keys()
    print(
        f'# TODO FIXME not found types.  {len(set(all_see_cls).difference(ole_cls_def_ns).difference(ocls).difference(oenums))}', file=ff)
    for i in sorted(all_see_cls):
        if i not in ole_cls_def_ns and not i in ocls and not i in oenums:
            print(f'class {i}: pass', file=ff)
    print(file=ff)

    # output ole empty class
    print_ole_empty(ff, ole_info_kvs, ole_cls_def_ns)

    out_collection_enumeration(ff, ole_info_kvs)
    print(file=ff)

    # print each class define
    print(f'# list ole_cls_def_strs  {len(ole_cls_defstrs)}', file=ff)
    for i in range(len(ole_cls_defstrs)):
        data = ole_cls_defstrs[i]  # order or reverse
        print(data, file=ff)

    print(f'## PRINT  {len(all_cls_kvs)}\n', file=sys.stderr)

    # get all
    data = ff.getvalue()

    # replace CoCobase
    hasbaseclss = list(filter(lambda x: True if x[0] == '_' else False, all_cls_kvs.keys()))
    for _base in hasbaseclss:
        cls = _base[1:]
        data = data.replace(f'class {cls}:', f'class {cls}({_base}):')

    # output all define
    with open(fn, 'w', encoding='utf-8') as fout:
        print(data, file=fout)

    print('base cls', len(hasbaseclss), sorted(hasbaseclss), file=sys.stderr)


def output_to_py_src(fn: str,
                     all_cls_kvs: dict[str, CDispatch],
                     ole_cls_def_ns: set,
                     ole_info_kvs: dict
                     ):
    '''all_cls_kvs.each -> "class XX: pass"'''
    with open(fn, 'w', encoding='utf-8') as ff:
        print(Cfg.OUTFILE_HEADER, file=ff)
        print(file=ff)
        print(Cfg.IMPORTS, file=ff)

        out_collection_enumeration(ff, ole_info_kvs)
        print(file=ff)

        print(f'# all_cls {len(all_cls_kvs)}', file=ff)
        for cl in all_cls_kvs:
            print(f'class {cl}: pass', file=ff)

        print(file=ff)
        print_ole_empty(ff, ole_info_kvs, ole_cls_def_ns)
    print(f'output to py class info file: {fn}', file=sys.stderr)


# ------------------------------------------------------------------------


def runit():
    all_cls_kvs: dict[str, CDispatch] = {}
    already_pr_cls: set[str] = set()
    ole_cls_def_ns: set = set()

    all_see_cls: set = set()
    unparsed_cls: set = set()
    ole_cls_defstrs: list[str] = []

    ole_info_kvs: dict[str, str] = {}

    load_info_from_json(Cfg.OUT_EXCEL_INFO_FN, ole_info_kvs)
    print('------------------------------------------', file=sys.stderr)

    exapp = Dispatch('excel.application')
    exapp.Visible = True

    wb = exapp.Workbooks.Add()
    ws = exapp.ActiveSheet
    ws.Range("A1:B3").Value = [[2, 4], [5, 6], [4, 6]]
    ws.Shapes.AddChart()

    cls_name = 'Application'
    all_cls_kvs[cls_name] = exapp

    for i in range(10000):
        if all_cls_kvs.keys() == already_pr_cls:
            print(f"## ALL DONE at {i}", file=sys.stderr)
            break
        for clsn in list(all_cls_kvs):
            exx = all_cls_kvs[clsn]
            cls_def_str = showinfo(clsn, exx, all_cls_kvs, already_pr_cls, all_see_cls,
                                   unparsed_cls, ole_info_kvs)
            # print(f'for {i}   {clsn}  {len(cls_def_str)}', file=sys.stderr)
            if cls_def_str:
                ole_cls_def_ns.add(clsn)
                ole_cls_defstrs.append(cls_def_str)
    print('------------------------------------------', file=sys.stderr)

    output_to_pyi_typehints(Cfg.OUT_EXCEL_PYI_FN, all_cls_kvs, unparsed_cls,
                            ole_cls_def_ns, ole_cls_defstrs, all_see_cls, ole_info_kvs)
    output_to_py_src(Cfg.OUT_EXCEL_PY_FN, all_cls_kvs, ole_cls_def_ns, ole_info_kvs)

    ws.Name = 'test'
    wb.Saved = True

    print('SUMMARY:', file=sys.stderr)
    print(f' unparsed_cls', len(unparsed_cls), sorted(unparsed_cls), file=sys.stderr)
    print(f' all_see_cls', len(all_see_cls), sorted(all_see_cls), file=sys.stderr)
    print(f' all_see_cls-already_pr_cls', sorted(set(all_see_cls).difference(already_pr_cls)), file=sys.stderr)
    print(f' already_pr_cls-all_see_cls', sorted(set(already_pr_cls).difference(all_see_cls)), file=sys.stderr)
    print(f' already_pr_cls.intersection all_see_cls', sorted(
        set(already_pr_cls).intersection(all_see_cls)), file=sys.stderr)
    print(file=sys.stderr)
    print(f' Print {len(already_pr_cls)} cls.\talready_pr_cls:', sorted(already_pr_cls), file=sys.stderr)
    print(f' {already_pr_cls == all_cls_kvs.keys()}\talready_pr_cls == all_cls_kvs.keys()', file=sys.stderr)
    print(f' {already_pr_cls == ole_cls_def_ns}\talready_pr_cls == ole_cls_def_ns', file=sys.stderr)
    print(f' {len(already_pr_cls) == len(ole_cls_defstrs)}\talready_pr_cls.size == ole_cls_defstrs.size', file=sys.stderr)


if __name__ == '__main__':
    check_or_exit()
    runit()
    tf2 = {}
    for i in Cfg.type_diff:
        v  = Cfg.type_diff[i]
        if v:
            tf2[i] = v
    pprint.pprint(tf2)
